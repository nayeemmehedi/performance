### **`useEffect` হুক কী? (React)**

`useEffect` হল React এর একটি হুক যা আপনাকে **side effects** পরিচালনা করতে সাহায্য করে। **Side effects** বলতে সাধারণত এমন কাজ বুঝানো হয় যেগুলি উপাদানের রেন্ডার হওয়ার পর ঘটতে পারে, যেমন:

- ডাটা ফেচিং
- সাবস্ক্রিপশন শুরু করা
- ডকুমেন্ট টাইটেল আপডেট করা
- টাইমার সেট করা
- ইভেন্ট লিসেনার যোগ করা ইত্যাদি

### **কেন `useEffect` প্রয়োজন?**
React কম্পোনেন্টের মধ্যে যখন কোনো **side effect** ঘটাতে হয়, তখন আমরা `useEffect` ব্যবহার করি। উদাহরণস্বরূপ, যদি আপনাকে কোনো API থেকে ডাটা আনতে হয়, বা কোনো DOM ম্যানিপুলেশন করতে হয়, তখন `useEffect` খুব কাজে আসে। এটি **render cycle** শেষে কাজ করে এবং আপনার অ্যাপ্লিকেশনের পারফরম্যান্স বাড়ায়।

---

### **`useEffect` এর মৌলিক ব্যবহার:**

```javascript
import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  // useEffect ব্যবহার করে side effect সম্পন্ন করা হচ্ছে
  useEffect(() => {
    document.title = `You clicked ${count} times`; // ডকুমেন্ট টাইটেল আপডেট হচ্ছে
  }, [count]); // dependency array: count পরিবর্তন হলে effect ট্রিগার হবে

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}
```

এখানে `useEffect` টাইটেল পরিবর্তন করার কাজটি করছে। `count` ভ্যালু পরিবর্তিত হলে `useEffect` আবার রান করবে এবং টাইটেল আপডেট হবে।

---

### **`useEffect` এর বিস্তারিত ব্যাখ্যা:**

`useEffect` দুইটি প্যারামিটার নেয়:

1. **প্রথম প্যারামিটার (Effect function)**: এটা একটি ফাংশন, যেখানে আপনি আপনার **side effect** লিখবেন।
2. **দ্বিতীয় প্যারামিটার (Dependency array)**: এটি একটি অ্যারে যেখানে আপনি নির্দিষ্ট ভ্যালু রাখেন, যেগুলি পরিবর্তিত হলে `useEffect` পুনরায় রান করবে। যদি এই অ্যারেটি খালি থাকে, তাহলে `useEffect` কেবল একবার রান করবে, কম্পোনেন্ট প্রথমবার মাউন্ট হওয়ার পর।

---

### **রিয়েল লাইফ উদাহরণ:**

ধরা যাক, আপনি একটি নিউজ অ্যাপ্লিকেশন তৈরি করছেন যেখানে প্রতিদিন নতুন নিউজ পাওয়া যায়। আপনি যদি প্রতিদিন নতুন খবর আনতে চান, তখন `useEffect` ব্যবহার করতে পারেন:

```javascript
import React, { useState, useEffect } from 'react';

function NewsApp() {
  const [news, setNews] = useState([]);
  const [loading, setLoading] = useState(true);

  // API থেকে নিউজ ডাটা ফেচ করা হচ্ছে
  useEffect(() => {
    // ডাটা ফেচিং কোড
    fetch('https://api.example.com/news')
      .then(response => response.json())
      .then(data => {
        setNews(data.articles);
        setLoading(false);
      })
      .catch(error => console.log(error));
  }, []); // এই কোডটি একবারই রান হবে, কারণ dependency array খালি

  if (loading) {
    return <p>Loading...</p>;
  }

  return (
    <div>
      <h1>Today's News</h1>
      <ul>
        {news.map((article, index) => (
          <li key={index}>{article.title}</li>
        ))}
      </ul>
    </div>
  );
}
```

এখানে `useEffect` ব্যবহার করা হয়েছে API থেকে ডাটা ফেচ করার জন্য। **Dependency array** খালি রেখেছি, যার মানে একবারই ফেচ করা হবে (কম্পোনেন্ট মাউন্ট হওয়ার পর)।

---

### **`useEffect` এর প্রধান ব্যবহার:**

1. **ডাটা ফেচিং**: কোনো API থেকে ডাটা ফেচ করতে।
2. **টাইমার বা ইন্টারভ্যাল সেট করা**: কোনো কাজ নির্দিষ্ট সময় পরপর করা।
3. **সাবস্ক্রিপশন**: ইভেন্ট সাবস্ক্রাইব করা, যেমন WebSocket বা Firebase এর সাথে কানেক্ট করা।
4. **ডকুমেন্ট ম্যানিপুলেশন**: DOM এর টাইটেল বা ক্লাস পরিবর্তন করা।

---

### **`useEffect` এর লাইফ সাইকেল**:

1. **Mounting**: প্রথমবার কম্পোনেন্ট রেন্ডার হওয়ার পর `useEffect` রান হয়।
2. **Updating**: যখন কম্পোনেন্টের স্টেট বা প্রপ্স পরিবর্তিত হয়, তখন `useEffect` আবার রান হতে পারে (যদি dependency array এ থাকা ভ্যালু পরিবর্তিত হয়)।
3. **Unmounting**: যদি আপনি `useEffect` থেকে কিছু ক্লিনআপ করতে চান (যেমন, ইভেন্ট লিসেনার অপসারণ), তবে আপনি `return` দিয়ে সেটা করতে পারেন।

```javascript
useEffect(() => {
  const timer = setInterval(() => console.log("Tick"), 1000);

  return () => clearInterval(timer); // ক্লিনআপ
}, []); 
```

---

### **সারাংশ**:
`useEffect` হল React এর একটি হুক যা side effects পরিচালনা করতে ব্যবহৃত হয়। এটি খুবই শক্তিশালী, বিশেষ করে যখন আপনি ডাটা ফেচিং, টাইমার, বা DOM ম্যানিপুলেশন করতে চান। এটি React অ্যাপ্লিকেশনের মধ্যে **বিহেভিয়র** কন্ট্রোল করতে ব্যবহৃত হয়, যাতে আপনার অ্যাপ্লিকেশন আরো ইন্টারেক্টিভ এবং কার্যকর হয়।


`useEffect` React এর একটি হুক যা মূলত **side effects** পরিচালনা করতে ব্যবহৃত হয়। `useEffect` এর মূল উদ্দেশ্য হলো কম্পোনেন্ট রেন্ডার হওয়ার পর কিছু কাজ সম্পন্ন করা, যেমন: ডাটা ফেচিং, ইভেন্ট হ্যান্ডলার যোগ করা, টাইটেল পরিবর্তন করা, টাইমার বা সাবস্ক্রিপশন শুরু করা ইত্যাদি।

### **`useEffect` এর উদ্দেশ্য কী?**
1. **Side effects** চালানো: যখন আপনি কোনো কোডকে এমনভাবে কার্যকর করতে চান যা রেন্ডারের সাথে সরাসরি সম্পর্কিত না, যেমন ডকুমেন্ট টাইটেল পরিবর্তন, টাইমার সেট করা, ইত্যাদি।
2. **ডিপেন্ডেন্সি (Dependencies)** নিয়ন্ত্রণ করা: `useEffect` কেবল তখনই রান হবে যখন আপনি dependency array এ থাকা ভ্যালুগুলো পরিবর্তন করবেন।

### **জীবনের বাস্তব উদাহরণে `useEffect` ব্যবহার**:

#### **১. দিন শুরু করার প্রস্তুতি** (Morning Routine)
ধরা যাক, আপনার প্রতিদিন সকালে একটি নির্দিষ্ট কাজের রুটিন আছে — আপনি ঘুম থেকে উঠেছেন, এবং আপনি আপনার দিনে কী করতে হবে তার জন্য প্রস্তুতি নিচ্ছেন। তবে আপনি যদি আপনার কাজের তালিকা দেখেন, তবে এটি আপনার দিনের পরিকল্পনাকে প্রভাবিত করবে। 

এটা যেমন `useEffect` এর মতো। আপনার প্রথম কাজ বা কাজের তালিকা দেখে আপনি আপনার কাজগুলো সাজাচ্ছেন, এবং **তালিকা পরিবর্তিত হলে** নতুন পরিকল্পনা গ্রহণ করছেন। যেমন, `useEffect` কেবল তখনই ট্রিগার হয় যখন আপনার নির্দিষ্ট কোন টাস্ক বা কাজের তালিকা পরিবর্তিত হয় (যেমন: স্টেট বা প্রপ্স পরিবর্তন)।

#### **২. টাইটেল বা তথ্য পরিবর্তন** (Changing Titles or Information)
ধরা যাক, আপনি একটি খবরের চ্যানেল দেখছেন। যখন খবরের শিরোনাম পরিবর্তিত হয়, তখন তা আপনার মনোযোগ আকর্ষণ করে এবং আপনি সেটি দেখেন। একইভাবে, `useEffect` কম্পোনেন্টের রেন্ডারিং এর পর কিছু পরিবর্তন বা আপডেট ঘটাতে ব্যবহৃত হয় — যেমন, একটি পৃষ্ঠার টাইটেল আপডেট করা বা নির্দিষ্ট ডেটা আপডেট করা।

#### **৩. বিজ্ঞপ্তি বা অ্যালার্ম** (Notifications or Alarms)
আপনার মোবাইলে যদি কোনো জরুরি অ্যালার্ম বা বিজ্ঞপ্তি আসে, তখন আপনি সেই বিজ্ঞপ্তির মাধ্যমে একটি কাজ শুরু করতে পারেন। এরকমভাবে `useEffect` কে ব্যবহার করা হয় যখন কম্পোনেন্টের কিছু পরিবর্তন ঘটে এবং আপনি সেই পরিবর্তন অনুযায়ী কিছু অ্যাকশন নিতে চান (যেমন, টাইমার সেট করা, ইভেন্ট সাবস্ক্রাইব করা ইত্যাদি)।

#### **৪. ডাটা আপডেট ও ট্র্যাকিং** (Tracking Data)
ধরা যাক, আপনি একটি ব্যাঙ্ক অ্যাপ ব্যবহার করছেন এবং আপনার ব্যালেন্স আপডেট হতে থাকে। আপনি যখন আপনার ব্যালেন্স দেখবেন, তখন সেখানে কিছু পরিবর্তন হবে। আপনাকে সর্বদা আপনার ব্যালেন্স ট্র্যাক করতে হবে। এখানে, `useEffect` এর কাজ হলো আপনার অ্যাপ্লিকেশনের যে কোন পরিবর্তন বা আপডেটের জন্য প্রস্তুত থাকা এবং সেই অনুযায়ী ট্র্যাকিং করা।

---

### **`useEffect` এর উদ্দেশ্য সংক্ষেপে:**
- **টাইমার সেট করা:** আপনার অ্যাপ্লিকেশন চলাকালীন কিছু সময় পর পর কাজ চালানো।
- **ডকুমেন্ট বা পেজের টাইটেল পরিবর্তন:** এক্ষেত্রে, আপনার `useEffect` ব্যবহার করে পেজের টাইটেল পরিবর্তন করতে পারেন।
- **অ্যালার্ম বা সাবস্ক্রিপশন:** সিস্টেমে কোন গুরুত্বপূর্ণ পরিবর্তন হলে আপনাকে অবহিত করতে পারবে।
- **কোনো কার্যকরী কার্যক্রম চালানো যা রেন্ডারিং এর পর প্রয়োজন।**

এভাবে, `useEffect` অ্যাপ্লিকেশনে কার্যক্রম বা সিস্টেমের বিভিন্ন পরিবর্তন বা আপডেট সমন্বয়ের জন্য ব্যবহার করা হয়, যেন আপনার অ্যাপ আরও কার্যকর এবং স্মার্ট হতে পারে।

নিচে কিছু উদাহরণ দেওয়া হলো, যা দিয়ে আপনি বুঝতে পারবেন `useEffect` কিভাবে ব্যবহার করা হয় ডাটা ফেচিং, টাইমার সেট করা, সাবস্ক্রিপশন, এবং ডকুমেন্ট ম্যানিপুলেশন এর জন্য:

### 1. **ডাটা ফেচিং (API থেকে ডাটা ফেচ করা)**

```javascript
import React, { useState, useEffect } from 'react';

function DataFetchingComponent() {
  const [data, setData] = useState(null);

  useEffect(() => {
    // API থেকে ডাটা ফেচ করা
    fetch('https://api.example.com/data')
      .then(response => response.json())
      .then(data => setData(data))
      .catch(error => console.error('Error fetching data:', error));
  }, []);  // Dependency array খালি রাখা, যাতে এটি শুধুমাত্র কম্পোনেন্ট প্রথমবার রেন্ডার হওয়ার পর রান হয়

  return (
    <div>
      {data ? (
        <pre>{JSON.stringify(data, null, 2)}</pre>
      ) : (
        <p>Loading data...</p>
      )}
    </div>
  );
}

export default DataFetchingComponent;
```

**ব্যাখ্যা**: এখানে `useEffect` ব্যবহার করা হয়েছে একটি API থেকে ডাটা ফেচ করতে। এটি প্রথমবার কম্পোনেন্ট রেন্ডার হলে রান হবে (কারণ ডিপেন্ডেন্সি অ্যারে খালি)। ডাটা ফেচ হলে, সেটি স্টেটে সংরক্ষণ করা হয় এবং UI তে দেখানো হয়।

---

### 2. **টাইমার বা ইন্টারভ্যাল সেট করা (Set a Timer)**

```javascript
import React, { useState, useEffect } from 'react';

function TimerComponent() {
  const [time, setTime] = useState(0);

  useEffect(() => {
    const timer = setInterval(() => {
      setTime(prevTime => prevTime + 1);  // প্রতি সেকেন্ডে টাইম বাড়ানো
    }, 1000);  // 1000 মিলিসেকেন্ড (1 সেকেন্ড)

    // Cleanup function: কম্পোনেন্ট আনমাউন্ট হলে টাইমার ক্লিয়ার করা হবে
    return () => clearInterval(timer);
  }, []);  // ডিপেন্ডেন্সি অ্যারে খালি রাখলে টাইমার শুধুমাত্র প্রথমবার রান হবে

  return <div>Time: {time} seconds</div>;
}

export default TimerComponent;
```

**ব্যাখ্যা**: এখানে একটি টাইমার তৈরি করা হয়েছে যা প্রতি সেকেন্ডে টাইম বাড়ায়। `useEffect` ব্যবহার করে টাইমার সেট করা হয় এবং কম্পোনেন্ট আনমাউন্ট হলে টাইমার ক্লিয়ার করা হয় (এটি পরিষ্কারভাবে পরিচালনার জন্য `return` এর মাধ্যমে `clearInterval` ব্যবহার করা হয়েছে)।

---

### 3. **সাবস্ক্রিপশন (Event Subscription with WebSocket)**

```javascript
import React, { useState, useEffect } from 'react';

function WebSocketComponent() {
  const [message, setMessage] = useState(null);

  useEffect(() => {
    const socket = new WebSocket('wss://example.com/socket');  // WebSocket URL

    // WebSocket এর মাধ্যমে মেসেজ গ্রহণ
    socket.onmessage = (event) => {
      setMessage(event.data);
    };

    // Cleanup: WebSocket বন্ধ করা যখন কম্পোনেন্ট আনমাউন্ট হবে
    return () => socket.close();
  }, []);  // ডিপেন্ডেন্সি অ্যারে খালি রাখলে WebSocket শুধু প্রথমবারই কানেক্ট হবে

  return (
    <div>
      {message ? (
        <p>Received message: {message}</p>
      ) : (
        <p>Waiting for message...</p>
      )}
    </div>
  );
}

export default WebSocketComponent;
```

**ব্যাখ্যা**: এখানে `WebSocket` এর মাধ্যমে রিয়েল-টাইম ডাটা সাবস্ক্রাইব করা হচ্ছে। যখন নতুন মেসেজ আসবে, তখন তা UI তে দেখানো হবে। কম্পোনেন্ট আনমাউন্ট হলে WebSocket কানেকশন বন্ধ করার জন্য `return` এর মাধ্যমে `socket.close()` ব্যবহার করা হয়েছে।

---

### 4. **ডকুমেন্ট ম্যানিপুলেশন (Document Manipulation - Title Change)**

```javascript
import React, { useEffect } from 'react';

function DocumentTitleComponent() {
  useEffect(() => {
    // ডকুমেন্টের টাইটেল পরিবর্তন করা
    document.title = 'New Page Title';

    // Cleanup function: টাইটেল আবার আগের অবস্থায় ফিরে আসবে যখন কম্পোনেন্ট আনমাউন্ট হবে
    return () => {
      document.title = 'Old Page Title';  // বা যেটি আপনি আগেই ব্যবহার করেছেন
    };
  }, []);  // প্রথমবার রেন্ডার হলে একবার রান হবে

  return <div>Check the document title!</div>;
}

export default DocumentTitleComponent;
```

**ব্যাখ্যা**: এখানে `useEffect` ব্যবহার করে ডকুমেন্টের টাইটেল পরিবর্তন করা হচ্ছে। যখন কম্পোনেন্ট আনমাউন্ট হবে তখন `cleanup` ফাংশন কাজ করবে এবং টাইটেল আগের অবস্থায় ফিরে আসবে।

---

এই উদাহরণগুলো দিয়ে আপনি দেখতে পাচ্ছেন যে `useEffect` কিভাবে বিভিন্ন রকম side effects পরিচালনা করতে সাহায্য করে, যেমন ডাটা ফেচিং, টাইমার সেট করা, ইভেন্ট সাবস্ক্রিপশন এবং ডকুমেন্ট ম্যানিপুলেশন।